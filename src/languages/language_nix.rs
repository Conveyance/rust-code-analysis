// Code generated; DO NOT EDIT.

use num_derive::FromPrimitive;

#[derive(Clone, Debug, PartialEq, Eq, FromPrimitive)]
pub enum Nix {
    End = 0,
    Keyword = 1,
    Identifier = 2,
    IntegerExpression = 3,
    FloatExpression = 4,
    PathFragment = 5,
    SpathExpression = 6,
    UriExpression = 7,
    COLON = 8,
    AT = 9,
    LBRACE = 10,
    RBRACE = 11,
    COMMA = 12,
    QMARK = 13,
    Ellipses = 14,
    Assert = 15,
    SEMI = 16,
    With = 17,
    Let = 18,
    In = 19,
    If = 20,
    Then = 21,
    Else = 22,
    BANG = 23,
    DASH = 24,
    EQEQ = 25,
    BANGEQ = 26,
    LT = 27,
    LTEQ = 28,
    GT = 29,
    GTEQ = 30,
    AMPAMP = 31,
    PIPEPIPE = 32,
    PLUS = 33,
    STAR = 34,
    SLASH = 35,
    DASHGT = 36,
    SLASHSLASH = 37,
    PLUSPLUS = 38,
    DOT = 39,
    Or = 40,
    LPAREN = 41,
    RPAREN = 42,
    Rec = 43,
    DQUOTE = 44,
    StringFragment = 45,
    EscapeSequence = 46,
    SQUOTESQUOTE = 47,
    EscapeSequence2 = 48,
    EQ = 49,
    Inherit2 = 50,
    DOLLARLBRACE = 51,
    DOLLARLBRACE2 = 52,
    LBRACK = 53,
    RBRACK = 54,
    Comment = 55,
    StringFragment2 = 56,
    StringFragment3 = 57,
    PathFragment2 = 58,
    PathFragment3 = 59,
    DollarEscape = 60,
    DollarEscape2 = 61,
    SourceCode = 62,
    Expression = 63,
    VariableExpression = 64,
    PathExpression = 65,
    HpathExpression = 66,
    ExprFunctionExpression = 67,
    FunctionExpression = 68,
    Formals = 69,
    Formal = 70,
    AssertExpression = 71,
    WithExpression = 72,
    LetExpression = 73,
    ExprIf = 74,
    IfExpression = 75,
    ExprOp = 76,
    HasAttrExpression = 77,
    UnaryExpression = 78,
    BinaryExpression = 79,
    ExprApplyExpression = 80,
    ApplyExpression = 81,
    ExprSelectExpression = 82,
    SelectExpression = 83,
    ExprSimple = 84,
    ParenthesizedExpression = 85,
    AttrsetExpression = 86,
    LetAttrsetExpression = 87,
    RecAttrsetExpression = 88,
    StringExpression = 89,
    IndentedStringExpression = 90,
    BindingSet = 91,
    Binding = 92,
    Inherit = 93,
    InheritFrom = 94,
    Attrpath = 95,
    InheritedAttrs = 96,
    Interpolation = 97,
    Interpolation2 = 98,
    ListExpression = 99,
    PathExpressionRepeat1 = 100,
    FormalsRepeat1 = 101,
    StringExpressionRepeat1 = 102,
    IndentedStringExpressionRepeat1 = 103,
    BindingSetRepeat1 = 104,
    AttrpathRepeat1 = 105,
    InheritedAttrsRepeat1 = 106,
    ListExpressionRepeat1 = 107,
    Error = 108,
    
}

impl From<Nix> for &'static str {
    #[inline(always)]
    fn from(tok: Nix) -> Self {
        match tok {
            Nix::End => "end",
            Nix::Keyword => "keyword",
            Nix::Identifier => "identifier",
            Nix::IntegerExpression => "integer_expression",
            Nix::FloatExpression => "float_expression",
            Nix::PathFragment => "path_fragment",
            Nix::SpathExpression => "spath_expression",
            Nix::UriExpression => "uri_expression",
            Nix::COLON => ":",
            Nix::AT => "@",
            Nix::LBRACE => "{",
            Nix::RBRACE => "}",
            Nix::COMMA => ",",
            Nix::QMARK => "?",
            Nix::Ellipses => "ellipses",
            Nix::Assert => "assert",
            Nix::SEMI => ";",
            Nix::With => "with",
            Nix::Let => "let",
            Nix::In => "in",
            Nix::If => "if",
            Nix::Then => "then",
            Nix::Else => "else",
            Nix::BANG => "!",
            Nix::DASH => "-",
            Nix::EQEQ => "==",
            Nix::BANGEQ => "!=",
            Nix::LT => "<",
            Nix::LTEQ => "<=",
            Nix::GT => ">",
            Nix::GTEQ => ">=",
            Nix::AMPAMP => "&&",
            Nix::PIPEPIPE => "||",
            Nix::PLUS => "+",
            Nix::STAR => "*",
            Nix::SLASH => "/",
            Nix::DASHGT => "->",
            Nix::SLASHSLASH => "//",
            Nix::PLUSPLUS => "++",
            Nix::DOT => ".",
            Nix::Or => "or",
            Nix::LPAREN => "(",
            Nix::RPAREN => ")",
            Nix::Rec => "rec",
            Nix::DQUOTE => "\"",
            Nix::StringFragment => "string_fragment",
            Nix::EscapeSequence => "escape_sequence",
            Nix::SQUOTESQUOTE => "''",
            Nix::EscapeSequence2 => "escape_sequence",
            Nix::EQ => "=",
            Nix::Inherit2 => "inherit",
            Nix::DOLLARLBRACE => "${",
            Nix::DOLLARLBRACE2 => "${",
            Nix::LBRACK => "[",
            Nix::RBRACK => "]",
            Nix::Comment => "comment",
            Nix::StringFragment2 => "string_fragment",
            Nix::StringFragment3 => "string_fragment",
            Nix::PathFragment2 => "path_fragment",
            Nix::PathFragment3 => "path_fragment",
            Nix::DollarEscape => "dollar_escape",
            Nix::DollarEscape2 => "dollar_escape",
            Nix::SourceCode => "source_code",
            Nix::Expression => "_expression",
            Nix::VariableExpression => "variable_expression",
            Nix::PathExpression => "path_expression",
            Nix::HpathExpression => "hpath_expression",
            Nix::ExprFunctionExpression => "_expr_function_expression",
            Nix::FunctionExpression => "function_expression",
            Nix::Formals => "formals",
            Nix::Formal => "formal",
            Nix::AssertExpression => "assert_expression",
            Nix::WithExpression => "with_expression",
            Nix::LetExpression => "let_expression",
            Nix::ExprIf => "_expr_if",
            Nix::IfExpression => "if_expression",
            Nix::ExprOp => "_expr_op",
            Nix::HasAttrExpression => "has_attr_expression",
            Nix::UnaryExpression => "unary_expression",
            Nix::BinaryExpression => "binary_expression",
            Nix::ExprApplyExpression => "_expr_apply_expression",
            Nix::ApplyExpression => "apply_expression",
            Nix::ExprSelectExpression => "_expr_select_expression",
            Nix::SelectExpression => "select_expression",
            Nix::ExprSimple => "_expr_simple",
            Nix::ParenthesizedExpression => "parenthesized_expression",
            Nix::AttrsetExpression => "attrset_expression",
            Nix::LetAttrsetExpression => "let_attrset_expression",
            Nix::RecAttrsetExpression => "rec_attrset_expression",
            Nix::StringExpression => "string_expression",
            Nix::IndentedStringExpression => "indented_string_expression",
            Nix::BindingSet => "binding_set",
            Nix::Binding => "binding",
            Nix::Inherit => "inherit",
            Nix::InheritFrom => "inherit_from",
            Nix::Attrpath => "attrpath",
            Nix::InheritedAttrs => "inherited_attrs",
            Nix::Interpolation => "interpolation",
            Nix::Interpolation2 => "interpolation",
            Nix::ListExpression => "list_expression",
            Nix::PathExpressionRepeat1 => "path_expression_repeat1",
            Nix::FormalsRepeat1 => "formals_repeat1",
            Nix::StringExpressionRepeat1 => "string_expression_repeat1",
            Nix::IndentedStringExpressionRepeat1 => "indented_string_expression_repeat1",
            Nix::BindingSetRepeat1 => "binding_set_repeat1",
            Nix::AttrpathRepeat1 => "attrpath_repeat1",
            Nix::InheritedAttrsRepeat1 => "inherited_attrs_repeat1",
            Nix::ListExpressionRepeat1 => "list_expression_repeat1",
            Nix::Error => "ERROR",
            
        }
    }
}

impl From<u16> for Nix {
    #[inline(always)]
    fn from(x: u16) -> Self {
        num::FromPrimitive::from_u16(x).unwrap_or(Self::Error)
    }
}

// Nix == u16
impl PartialEq<u16> for Nix {
    #[inline(always)]
    fn eq(&self, x: &u16) -> bool {
        *self == Nix::from(*x)
    }
}

// u16 == Nix
impl PartialEq<Nix> for u16 {
    #[inline(always)]
    fn eq(&self, x: &Nix) -> bool {
        *x == *self
    }
}